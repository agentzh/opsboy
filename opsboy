#!/usr/bin/env perl

use strict;
use warnings;

use Getopt::Std;
use Parse::RecDescent;
use Data::Dumper;
use File::Copy;

my %opts;
getopts("co:", \%opts) or
    die "Usage: $0 [-c] <input-file>\n";

my $compile_only = $opts{c};
my $outfile = $opts{o} || "a.pl";

$Parse::RecDescent::skip = '(?:\s*\#[^\n]*\s*)+|\s*';

my $parser = Parse::RecDescent->new(<<'END_GRAMMAR');
spec: target(s?) eof { $item[1] }
    | <error>

eof: /^\Z/

target: identifier '=' <commit> argument ';'
            { $return = { $item[1] => $item[4] } }
      | identifier block { [$item[1], $item[2]] }
      | <error?>

block: '{' rule(s?) '}' { $item[2] }
     | <error>

rule: command argument(s?) ';' { [$item[1], $item[2]] }
    | <error>

command: 'git'
       | 'file'
       | 'running'
       | 'dir'
       | 'dep'
       | 'cwd'
       | 'test'
       | 'env'
       | 'always'
       | 'sh'
       | 'yum'
       | 'prog'
       | 'fetch'
       | 'tarball'
       | 'cpan'
       | <error>

argument: /'(?:\\.|[^\\'])*'/ { eval $item[1] }
        | /[^;"\s]+/
        | <error>

identifier: /[A-Za-z][-\w]*/
          | <error>

END_GRAMMAR

my $infile = shift or
    die "No input file specified.\n";

open my $in, $infile or
    die "Cannot open $infile for reading: $!\n";

my $src = do { local $/; <$in> };

my $ast = $parser->spec($src) or
    die "Failed to parse $infile: Bad grammar.\n";

#print Dumper($ast);

my $default_goal;
my %entities;
my %vars;
#my $i = 0;
for my $target (@$ast) {
    #warn "$i: ref: ", ref($target);
    #$i++;
    if (!ref $target) {
        die "Unknown target: $target";
    }

    if (ref $target eq 'HASH') {
        # variable assignment
        while (my ($name, $val) = each %$target) {
            #warn "$name = $val\n";
            $vars{$name} = $val;
        }

        next;
    }

    my ($name, $rules) = @$target;
    if (!$default_goal) {
        $default_goal = $name;
    }

    #warn "target: $name\n";
    if ($entities{$name}) {
        die "target \"$name\" redefined.\n";
    }

    my %rules;

    $entities{$name} = \%rules;

    for my $rule (@$rules) {
        my ($cmd, $args) = @$rule;
        if ($rules{$cmd}) {
            push @{ $rules{$cmd} }, @$args;

        } else {
            $rules{$cmd} = $args;
        }
    }

    my $deps = $rules{dep};

    my $gits = $rules{git};
    if ($gits) {
        if (!$deps) {
            $rules{dep} = ['git'];
        } else {
            unshift @$deps, 'git';
        }
    }

    my $cpans = $rules{cpan};
    if ($cpans) {
        if (!$deps) {
            $rules{dep} = ['cpan'];
        } else {
            unshift @$deps, 'cpan';
        }
    }
}

for my $name (keys %entities) {
    my $rules = $entities{$name};
    my $deps = $rules->{dep};
    if ($deps) {
        for my $dep (@$deps) {
            if (!$entities{$dep}) {
                die "Entity $dep is required by $name but is not defined.\n";
            }
        }
    }
}

#warn "default goal: $default_goal\n";

open my $out, ">$outfile" or
    die "Cannot open $outfile for writing: $!\n";

my $data = \*DATA;
while (<$data>) {
    print $out $_;
}

print $out "\$default_goal = '$default_goal';\n\n";

$Data::Dumper::Indent = 1;

print $out Data::Dumper->Dump([\%vars], ['vars']);

print $out "\n";

print $out Data::Dumper->Dump([\%entities], ['entities']);

print $out "\nmain();\n";
close $out;

chmod 0700, $outfile or
    die "failed to chmod 0700 $outfile: $!\n";

__DATA__
#!/usr/bin/env perl

use 5.006001;
use strict;
use warnings;

use File::Spec;

my ($default_goal, $entities, $vars);
my ($check_only, $git_pull);

my (%made, %making);

sub make ($);
sub check_dir ($);
sub main ();
sub can_run ($);
sub sh (@);

sub make ($) {
    my $target = shift;

    if ($made{$target}) {
        return;
    }

    if ($making{$target}) {
        die "Circular dependency found around $target\n";
    }

    $making{$target} = 1;

    my $rules = $entities->{$target};
    if (!$rules) {
        die "target \"$target\" not defined.\n";
    }

    my $deps = $rules->{dep};

    my $gits = $rules->{git};
    if ($gits) {
        if (!$deps) {
            $rules->{dep} = ['git'];
        } else {
            unshift @$deps, 'git';
        }
    }

    if ($deps) {
        for my $dep (@$deps) {
            make($dep);
        }
    }

    warn "making $target ...\n";

    my $envs = $rules->{env};
    if (defined $envs) {
        my @vals = @$envs;
        while (@vals) {
            my $name = shift @vals;
            if (!defined $name) {
                die "Undefined environment name.\n";
            }

            my $value = shift @vals;
            if (!defined $value) {
                die "Environment $name does not take a value.\n";
            }

            $value =~ s/\$(\w+)/defined $ENV{$1} ? $ENV{$1} : ''/ge;
            $value =~ s/^~/$ENV{HOME}/;
            #warn "Setting $name to $value\n";
            $ENV{$name} = $value;
        }
    }

    if ($gits) {
        if (@$gits % 2 != 0) {
            die "Bad number of arguments to the \"git\" command: ",
                scalar(@$gits);
        }

        my @args = @$gits;
        while (@args) {
            my $url = shift @args;
            my $dir = shift @args;

            $dir =~ s/^~/$ENV{HOME}/;

            my $parent;
            if ($dir =~ m{(.+/)[^/]+$}) {
                $parent = $1;
                if (!-d $parent) {
                    sh("mkdir", "-p", $parent);
                }
            }

            if (!good_git_repos($dir)) {
                if (-d $dir) {
                    sh("rm", "-rf", "$dir/*");
                    sh("rm", "-rf", "$dir/.git");
                }

                sh("git", "clone", $url, $dir);

            } else {
                if ($git_pull) {
                    sh("cd $dir && git pull");
                }
            }
        }
    }

    my $requires_making;

    my $progs = $rules->{prog};
    if ($progs) {
        for my $prog (@$progs) {
            if (!can_run($prog)) {
                warn "program $prog missing.\n";
                $requires_making = 1;
                last;
            }
        }
    }

    my $tests = $rules->{test};
    if ($tests) {
        #warn "Found tests!";
        for my $test (@$tests) {
            #warn "running command $test";
            if (system($test) != 0) {
                warn "shell test failed: $test\n";
                $requires_making = 1;
                last;
            }
        }
    }

    my $runnings = $rules->{running};
    if ($runnings) {
        for my $running (@$runnings) {
            if (system("ps aux|grep '$running'|grep -v grep") != 0) {
                warn "process matching '$running' not found.\n";
                $requires_making = 1;
                last;
            }
        }
    }

    my $files = $rules->{file};
    if ($files) {
        for my $file (@$files) {
            $file =~ s/^~/$ENV{HOME}/;
            $file =~ s/\$(\w+)/defined $ENV{$1} ? $ENV{$1} : ''/eg;
            if (!-e $file) {
                $requires_making = 1;
                last;
            }
        }
    }

    if ($rules->{always}) {
        $requires_making = 1;
    }

    if ($requires_making) {
        my $pkgs = $rules->{yum};
        if ($pkgs) {
            for my $pkg (@$pkgs) {
                sh("sudo", "yum", "install", $pkg, "-y");
            }
        }

        my $cpans = $rules->{cpan};
        if ($cpans) {
            for my $cpan (@$cpans) {
                sh("sudo", "cpan", $cpan);
            }
        }

        my $cwds = $rules->{cwd};
        if (defined $cwds) {
            for my $cwd (@$cwds) {
                $cwd =~ s/^~/$ENV{HOME}/;
                if (!-d $cwd) {
                    system("mkdir -p $cwd") == 0 or die "Cannot mkdir $cwd\n";
                }
                chdir $cwd or die "Cannot cd to $cwd\n";
            }
        }

        my $fetches = $rules->{fetch};
        if (defined $fetches) {
            for my $fetch (@$fetches) {
                $fetch =~ s/\$(\w+)/$ENV{$1}/g;
                sh('wget', '-N', $fetch);
            }
        }

        my $tarballs = $rules->{tarball};
        if (defined $tarballs) {
            for my $tarball (@$tarballs) {
                $tarball =~ s/\$(\w+)/$ENV{$1}/g;
                sh('tar', '-xvf', $tarball);
            }
        }

        my $cmds = $rules->{sh};
        if ($cmds) {
            for my $cmd (@$cmds) {
                $cmd =~ s/\$(\w+)/defined $ENV{$1} ? $ENV{$1} : ''/ge;
                #warn "CMD: [$cmd]";
                sh($cmd);
            }
        }
    }

    $made{$target} = 1;
}

sub sh (@) {
    print "@_\n";

    if (!$check_only) {
        if (system(@_) != 0) {
            die "failed to run command: $?\n";
        }
    }
}

sub good_git_repos ($) {
    my $dir = shift;
    if (-d $dir && -d "$dir/.git"
        && -d "$dir/.git/refs" && -d "$dir/.git/objects") {
        #print "good git repos $dir.\n";
        return 1;
    }

    return undef;
}

sub check_dir ($) {
    my $dir = shift;
    $dir =~ s/^~/$ENV{HOME}/;
    if (-d $dir) {
        print "Directory $dir exists.\n";

    } else {
        print "Directory $dir NOT exists.\n";
    }
}

sub main () {
    my $cmd = shift @ARGV or
        die "No command specified.\n";

    while (my ($var, $val) = each %$vars) {
        $ENV{$var} = $val;
    }

    if ($cmd eq 'check') {
        $check_only = 1;

    } elsif ($cmd eq 'make') {
        undef $check_only;

    } else {
        die "unknown command: $cmd\n";
    }

    my $begin = time();

    if (@ARGV) {
        my @goals;
        for my $arg (@ARGV) {
            if ($arg =~ /^([A-Za-z][-\w]*)=(.*)/) {
                $ENV{$1} = $2;
                next;
            }

            if ($arg =~ /^-/) {
                if ($arg eq '--git-pull') {
                    $git_pull = 1;

                } else {
                    die "unknown option: $arg\n";
                }

                next;
            }

            push @goals, $arg;
        }

        for my $goal (@goals) {
            make ($goal);
        }

    } else {
        make($default_goal);
    }

    my $elapsed = time() - $begin;
    warn "For total $elapsed sec elapsed.\n";
}

# check if we can run some command
sub can_run ($) {
    my ($cmd) = @_;

    #warn "can run: @_\n";
    my $_cmd = $cmd;
    return $_cmd if -x $_cmd;

    return undef if $_cmd =~ m{[\\/]};

    # FIXME: this is a hack; MSWin32 is not supported anyway
    my $path_sep = ':';

    for my $dir ((split /$path_sep/, $ENV{PATH}), '.') {
        next if $dir eq '';
        my $abs = File::Spec->catfile($dir, $_[0]);
        return $abs if -x $abs;
    }

    return undef;
}


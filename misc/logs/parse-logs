#!/usr/bin/env perl

use strict;
use warnings;

use Date::Parse;
use Getopt::Std;
use List::MoreUtils qw( uniq );
use JSON::XS;
use List::Util qw( max sum );

my %opts;
getopts('vo:', \%opts) or usage();

my $outfile = $opts{o} or usage();

my $verbose = $opts{v};

my %white_list = (
    'lua-resty-lrucache' => [
        ['v', 'sanity.t', 'TEST 4: ttl - response_body - response is expected'],
    ],

    'lua-resty-upstream-healthcheck' => [
        ['v', 'sanity.t', ' - grep_error_log_out'],
        ['v', 'sanity.t', 'TEST 6: health check (bad case), bad status, and then rise again - response_body - response is expected'],
        ['v', 'sanity.t', 'TEST 4: health check (bad case), bad status - response_body - response is expected'],
        ['v', 'sanity.t', 'TEST 5: health check (bad case), timed out - response_body - response is expected'],
        ['rv', 'sanity.t', 'TEST 4: health check (bad case), bad status - response_body - response is expected'],
        ['rv', 'sanity.t', ' - grep_error_log_out'],
        ['rv', 'sanity.t', 'TEST 6: health check (bad case), bad status, and then rise again - response_body - response is expected'],
        ['rv', 'sanity.t', 'TEST 7: peers version upgrade (make up peers down) - response_body - response is expected'],
        ['w', 'sanity.t', 'TEST 6: health check (bad case), bad status, and then rise again - response_body - response is expected'],
        ['w', 'sanity.t', 'TEST 5: health check (bad case), timed out - grep_error_log_out'],
        ['w', 'sanity.t', 'TEST 4: health check (bad case), bad status - grep_error_log_out'],
        ['w', 'sanity.t', 'TEST 9: concurrency == 2 (odd number of peers) - grep_error_log_out'],
        ['w', 'sanity.t', 'TEST 3: health check (bad case), no listening port in a primary peer - grep_error_log_out'],
        ['w', 'sanity.t', 'TEST 1: health check (good case), status ignored by default - grep_error_log_out'],
        ['w', 'sanity.t', 'TEST 2: health check (bad case), no listening port in the backup peer - grep_error_log_out'],
        ['w', 'sanity.t', 'TEST 7: peers version upgrade (make up peers down)'],
        ['w', 'sanity.t', 'TEST 6: health check (bad case), bad status, and then rise again - grep_error_log_out'],
        ['w', 'sanity.t', 'TEST 10: concurrency == 3 (odd number of peers) - grep_error_log_out'],
        ['wv', 'sanity.t', 'TEST 3: health check (bad case), no listening port in a primary peer - response_body - response is expected'],
        ['wv', 'sanity.t', 'TEST 5: health check (bad case), timed out - grep_error_log_out'],
        ['wv', 'sanity.t', 'TEST 6: health check (bad case), bad status, and then rise again - response_body - response is expected'],
        ['wv', 'sanity.t', 'TEST 4: health check (bad case), bad status - response_body - response is expected'],
        ['wv', 'sanity.t', 'TEST 2: health check (bad case), no listening port in the backup peer - response_body - response is expected'],
        ['wv', 'sanity.t', 'TEST 8: peers version upgrade (make down peers up) - response_body - response is expected'],
        ['wv', 'sanity.t', 'TEST 8: peers version upgrade (make down peers up) - grep_error_log_out'],
        ['wv', 'sanity.t', 'TEST 5: health check (bad case), timed out - response_body - response is expected'],
        ['h', 'sanity.t', 'TEST 10: concurrency == 3 (odd number of peers) - pattern "healthcheck: peer 127.0.0.1:12359 is turned down after 2 failure(s)" matches a line in error.log'],
        ['h', 'sanity.t', 'TEST 10: concurrency == 3 (odd number of peers) - pattern "healthcheck: peer 127.0.0.1:12356 is turned down after 2 failure(s)" matches a line in error.log'],
        ['h', 'sanity.t', 'TEST 10: concurrency == 3 (odd number of peers) - pattern "healthcheck: peer 127.0.0.1:12355 is turned down after 2 failure(s)" matches a line in error.log'],
        ['h', 'sanity.t', ' - grep_error_log_out'],
        ['h', 'sanity.t', 'TEST 5: health check (bad case), timed out - response_body - response is expected'],
        ['h', 'sanity.t', 'TEST 1: health check (good case), status ignored by default - pattern "was checked to be not ok" should not match any line in error.log but matches line'],
        ['h', 'sanity.t', 'TEST 1: health check (good case), status ignored by default - pattern "[warn]" should not match any line in error.log but matches line'],
        ['h', 'sanity.t', 'TEST 7: peers version upgrade (make up peers down) - pattern "was checked to be not ok" should not match any line in error.log but matches line'],
        ['h', 'sanity.t', qr/TEST 9: concurrency == 2 \(odd number of peers\) - pattern ".*?" matches a line in error\.log/],
        ['h', 'sanity.t', 'TEST 7: peers version upgrade (make up peers down) - pattern "[error]" should not match any line in error.log but matches line'],
        ['h', 'sanity.t', 'TEST 10: concurrency == 3 (odd number of peers) - pattern "healthcheck: peer 127.0.0.1:12354 is turned down after 2 failure(s)" matches a line in error.log'],
        ['h', 'sanity.t', 'TEST 6: health check (bad case), bad status, and then rise again - response_body - response is expected'],
        ['hv', 'sanity.t', 'TEST 10: concurrency == 3 (odd number of peers) - pattern "healthcheck: peer 127.0.0.1:12359 is turned down after 2 failure(s)" matches a line in error.log'],
    ],

    'lua-resty-mysql' => [
        ['v', 'world.t', 'ERROR: client socket timed out - TEST 1: test an old bug in table.new() on i386 in luajit v2.1'],
        ['v', 'world.t', 'TEST 1: test an old bug in table.new() on i386 in luajit v2.1 - status code ok'],
        ['v', 'world.t', 'TEST 1: test an old bug in table.new() on i386 in luajit v2.1 - response_body - response is expected'],
        ['v', 'sanity.t', 'TEST 10: multiple select queries - response_body - response is expected'],
        ['v', 'sanity.t', qr/TEST 10: multiple select queries - pattern "\[error\]" should not match any line in error\.log but matches line .*? lua tcp socket read timed out/],
        ['r', 'world.t', 'ERROR: client socket timed out - TEST 1: test an old bug in table.new() on i386 in luajit v2.1'],
        ['r', 'world.t', 'TEST 1: test an old bug in table.new() on i386 in luajit v2.1 - status code ok'],
        ['r', 'world.t', 'TEST 1: test an old bug in table.new() on i386 in luajit v2.1 - response_body - response is expected'],
    ],

    'lua-resty-redis' => [
        ['w', 'mock.t', 'TEST 1: continue using the obj when read timeout happens - tcp_query ok'],
    ],

    'lua-resty-logger-socket' => [
        ['v', 'sanity.t', 'matches a line in error.log'],
        ['v', 'timeout.t', 'matches a line in error.log'],
        ['v', 'timeout.t', 'TEST 5: flush race condition - pattern "tcp socket connect timed out" should not match any line in error.log but matches line'],
        ['v', 'bug.t', 'TEST 1: small flush_limit, instant flush - grep_error_log_out'],
        ['h', 'timeout.t', 'should not match any line in error.log but matches line'],
        ['h', 'timeout.t', 'matches a line in error.log'],
        ['h', 'bug.t', 'TEST 1: small flush_limit, instant flush - grep_error_log_out'],
        ['rv', 'sanity.t', qr/TEST 7: log subrequest, flush twice - pattern "\[error\]" should not match any line in error\.log but matches line .*? lua tcp socket connect timed out, context: ngx\.timer/],
        ['rv', 'sanity.t', 'TEST 9: partial flush - tcp_query ok'],
        ['rv', 'sanity.t', qr/TEST 9: partial flush - pattern "\[error\]" should not match any line in error\.log but matches line .*? lua tcp socket connect timed out, context: ngx\.timer/],
        ['v', 'sanity.t', 'TEST 12: drop log test - tcp_query ok'],
        ['v', 'sanity.t', 'TEST 12: drop log test - TCP query length ok'],
        ['v', 'sanity.t', 'TEST 2: small flush_limit, instant flush, unix domain socket - tcp_query ok'],
        ['v', 'sanity.t', 'TEST 2: small flush_limit, instant flush, unix domain socket - TCP query length ok'],
        ['v', 'sanity.t', 'TEST 1: small flush_limit, instant flush - tcp_query ok'],
        ['v', 'sanity.t', 'TEST 1: small flush_limit, instant flush - TCP query length ok'],
        ['v', 'sanity.t', 'TEST 3: small flush_limit, instant flush, write a number to remote - tcp_query ok'],
        ['v', 'sanity.t', 'TEST 3: small flush_limit, instant flush, write a number to remote - TCP query length ok'],
        ['v', 'timeout.t', 'TEST 3: risk condition - tcp_query ok'],
        ['v', 'timeout.t', 'TEST 3: risk condition - TCP query length ok'],
    ],

    'lua-resty-lock' => [
        ['v', 'sanity.t', 'TEST 4: waited locks - response_body_like - response is expected'],
        ['v', 'sanity.t', 'TEST 5: waited locks (custom step) - response_body_like - response is expected'],
        ['v', 'sanity.t', 'TEST 6: waited locks (custom ratio) - response_body_like - response is expected'],
        ['v', 'sanity.t', 'TEST 7: waited locks (custom max step) - response_body_like - response is expected'],
        ['v', 'sanity.t', 'TEST 8: lock expired by itself - response_body_like - response is expected'],
    ],

    'lua-resty-websocket' => [
        ['h', 'cs.t', 'TEST 14: pool option - pattern "lua tcp socket keepalive create connection pool for key "my_conn_pool"" matches a line in error.log (req 1)'],
        ['v', 'cs.t', 'matches a line in error.log'],
        ['v', 'cs.t', 'TEST 10: client recv timeout (timeout option) - response_body - response is expected'],
        ['v', 'sanity.t', 'ERROR: client socket timed out - TEST 9: simple text data frame (1 Mbytes)'],
        ['v', 'sanity.t', 'matches a line in error.log'],
        ['v', 'sanity.t', qr/TEST 9: simple text data frame \(1 Mbytes\) - (?:header \S+|status code) ok/],
        ['r', 'sanity.t', 'TEST 16: text frame (send unmasked frames on the client side) - response_body - response is expected'],
        ['r', 'sanity.t', 'ERROR: client socket timed out - TEST 8: simple text data frame (65536 bytes)'],
        ['r', 'sanity.t', 'TEST 8: simple text data frame (65536 bytes) - pattern "text msg received is expected," matches a line in error.log'],
        ['r', 'sanity.t', 'ERROR: client socket timed out - TEST 7: simple text data frame (65535 bytes)'],
        ['r', 'sanity.t', 'TEST 7: simple text data frame (65535 bytes) - pattern "text msg received is expected," matches a line in error.log'],
        ['r', 'sanity.t', 'ERROR: client socket timed out - TEST 9: simple text data frame (1 Mbytes)'],
        ['r', 'sanity.t', 'TEST 9: simple text data frame (1 Mbytes) - pattern "text msg received is expected," matches a line in error.log'],
        ['r', 'cs.t', 'TEST 16: text frame (send unmasked frames on the client side) - response_body - response is expected'],
        ['rv', 'cs.t', 'TEST 10: client recv timeout (timeout option) - response_body - response is expected'],
        ['wv', 'cs.t', 'TEST 10: client recv timeout (timeout option) - response_body - response is expected'],
        ['wv', 'cs.t', 'TEST 16: text frame (send unmasked frames on the client side) - response_body - response is expected'],
        ['hv', 'sanity.t', 'TEST 13: close frame (no payload at all) - pattern "[error]" should not match any line in error.log but matches line'],
        ['hv', 'sanity.t', 'TEST 18: simple text data frame (3 bytes, fragmented, first frame) - pattern "[error]" should not match any line in error.log but matches line'],
        ['hv', 'sanity.t', 'TEST 4: simple text data frame (125 bytes) - pattern "[error]" should not match any line in error.log but matches line'],
        ['hv', 'sanity.t', 'TEST 19: simple text data frame (3 bytes, fragmented, last frame) - pattern "[error]" should not match any line in error.log but matches line'],
        ['hv', 'sanity.t', 'TEST 16: pong frame (with payload) - pattern "[error]" should not match any line in error.log but matches line'],
        ['hv', 'sanity.t', 'TEST 8: simple text data frame (65536 bytes) - pattern "[error]" should not match any line in error.log but matches line'],
        ['hv', 'sanity.t', 'TEST 10: simple binary data frame (3 bytes) - pattern "[error]" should not match any line in error.log but matches line'],
        ['hv', 'sanity.t', 'TEST 11: close frame (status code + non-empty msg) - pattern "[error]" should not match any line in error.log but matches line'],
        ['hv', 'sanity.t', 'TEST 2: simple text data frame (3 bytes) - pattern "[error]" should not match any line in error.log but matches line'],
        ['hv', 'sanity.t', 'TEST 6: simple text data frame (127 bytes) - pattern "[error]" should not match any line in error.log but matches line'],
    ],

    'lua-resty-dns' => [
        ['v', 'mock.t', qr/pattern "\[error\]" should not match any line in error.log but matches line ".*?lua udp socket read timed out/],
        ['v', 'mock.t', 'TEST 10: timeout - response_body - response is expected'],
        ['v', 'mock.t', 'pattern "lua udp socket read timed out" matches a line in error.log'],
        ['v', 'sanity.t', qr/TEST 8: TXT query \(no ans\) - pattern "\[error\]" should not match any line in error.log but matches line .*? lua udp socket read timed out/],
        ['rv', 'sanity.t', qr/TEST 7: NS records - pattern "\[error\]" should not match any line in error\.log but matches line .*? lua udp socket read timed out/],
        ['hv', 'sanity.t', qr/TEST 7: NS records - pattern "\[error\]" should not match any line in error\.log but matches line .*? lua udp socket read timed out/],
    ],

    ngx_rds_csv => [
        ['w', '000_init.t', 'TEST 11: cats - drop table'],
        ['w', '000_init.t', 'TEST 12: cats - create table'],
        ['w', '000_init.t', 'TEST 13: cats - insert value'],
        ['w', '000_init.t', 'TEST 14: cats - insert value'],
        ['w', 'pg.t'],
        ['w', 'unused.t', 'TEST 1: used - stap output expected'],
        ['w', 'unused.t', 'TEST 3: used (multi http {} blocks) - stap output expected'],
        ['r', 'sanity-stream.t', 'TEST 1: sanity'],
        ['r', 'sanity-stream.t', 'TEST 2: keep-alive'],
        ['r', 'sanity-stream.t', 'TEST 7: single row, single col'],
        ['r', 'sanity-stream.t', 'TEST 9: text blob field'],
        ['r', 'sanity-stream.t', 'TEST 12: date type'],
    ],

    ngx_replace_filter => [
        ['w', '09-unused.t', 'TEST 1: used - stap output expected'],
        ['w', '09-unused.t', 'TEST 3: used (multi http {} blocks) - stap output expected'],
    ],

    #ngx_postgres => [['w']],

    ngx_form_input => [
        ['r', 'upload.t', 'TEST 1: big upload'],
        ['r', 'upload.t', 'Looks like you planned 2 tests but ran 3'],
    ],

    ngx_set_misc => [
        ['v', 'formatted-time.t', 'TEST 1: local time format - response_body_like - response is expected'],
        ['v', 'formatted-time.t', 'TEST 2: GMT time format - response_body_like - response is expected'],
    ],

    ngx_memc => [
        ['v', 'exptime.t', 'TEST 1: set exptime - response_body_like'],
        ['w', 'keepalive/storage.t', 'TEST 18: set and get too big values'],
        ['r', 'keepalive/storage.t', 'TEST 18: set and get too big values'],
        ['w', 'storage.t', 'TEST 18: set and get too big values'],
        ['r', 'storage.t', 'TEST 18: set and get too big values'],
        ['r', 'storage.t', 'Looks like you planned 76 tests but ran 78.'],
        ['r', 'keepalive/storage.t', 'Looks like you planned 74 tests but ran 76.'],
    ],

    ngx_rds_json => [
        ['o', undef, 'matches a line in error.log'],
        ['w', 'pg.t'],
        ['w', '000_init.t', 'TEST 8: cats - drop table'],
        ['w', '000_init.t', 'TEST 9: cats - create table'],
        ['w', '000_init.t', 'TEST 10: cats - insert value'],
        ['w', '000_init.t', 'TEST 11: cats - insert value'],
    ],

    ngx_encrypted_session => [
        ['o', undef, 'matches a line in error.log'],
    ],

    ngx_srcache => [
        ['o', undef, 'matches a line in error.log'],
        ['w', 'postgres-main.t'],
        ['w', 'bugs.t', qr/pattern "\[error\]" should not match any line in error\.log but matches line .*? writev\(\) failed/],
        ['w', 'bugs.t', 'TEST 14: upstream closes the connection prematurely in srcache_fetch - pattern "upstream prematurely closed connection" matches a line in error.log'],
        ['w', '000_init.t', '- pg -'],
        ['w', 'conditional-get.t', 'TEST 7: cache hit (I-U-S conditional GET, 412) - '],
        ['v', 'store-max-size.t', 'TEST 8: just more than store_max_size - pattern "store status: BYPASS" matches a line in error.log'],
    ],

    'lua-resty-core' => [
        [undef, 're-match.t', qr/TEST 2: matched, no submatch, jit compile, regex cache - pattern ".*?TRACE .*?" matches a line in error\.log/], # FIXME
        ['v', 're-sub.t', 'ERROR: client socket timed out - TEST 5: replace template + submatches (exceeding buffers)'],
        ['v', 're-sub.t', 'TEST 5: replace template + submatches (exceeding buffers) - status code ok'],
        ['v', 're-sub.t', 'TEST 5: replace template + submatches (exceeding buffers) - response_body - response is expected'],
        ['h', 'shdict.t', 'TEST 2: get an nonexistent key - response_body - response is expected'],
        ['h', 'request.t', qr/TEST 3: ngx.req.get_headers \(count is 2\) - pattern .*?TRACE.*? matches a line in error\.log/],
    ],

    ngx_lua => [
        ['w', '005-exit.t', 'TEST 24: exit 444 in header filter - status code ok'],
        ['w', '005-exit.t', 'TEST 22: exit 201 in header filter - status code ok'],
        ['w', '005-exit.t', 'TEST 23: exit both in header filter and content handler - status code ok'],
        ['w', '005-exit.t', 'TEST 21: exit 403 in header filter - status code ok'],
        ['w', '005-exit.t', 'TEST 21: exit 403 in header filter - response_body_like - response is expected'],
        ['', '123-lua-path.t', 'TEST 1: LUA_PATH & LUA_CPATH env (code cache on)', qr{/lua-resty-core/lib/\?\.lua}],
        ['', '123-lua-path.t', 'TEST 2: LUA_PATH & LUA_CPATH env (code cache off)', qr{/lua-resty-core/lib/\?\.lua}],
        ['', '004-require.t', qr{TEST 3: expand default path \(after\) - response_body_like - response is expected \(/\S+/lua-resty-core/lib/\?\.lua},],
        ['', '025-codecache.t', 'nginx: [alert]'],
        ['v', '025-codecache.t', 'matches a line in error.log'],
        ['v', '109-timer-hup.t', 'TEST 6: HUP reload should abort pending timers (coroutine + cosocket) - grep_error_log_out'],
        ['w', '025-codecache.t', 'TEST 29: cosocket connection pool timeout (after Lua VM destroys) - pattern "lua tcp socket keepalive max idle timeout" should not match any line in error.log but matches line'],
        ['w', '025-codecache.t', 'TEST 24: lua_max_pending_timers - chained timers (non-zero delay) - not exceeding - pattern "decrementing the reference count for Lua VM: 3" should not match any line in error.log but matches line'],
        ['o', undef, 'matches a line in error.log'],
        ['o', undef, ' - grep_error_log_out'],
        ['r', '071-idle-socket.t', 'TEST 6: set keepalive when cosocket recv buffer has unread data'],
        ['r', '106-timer.t', 'matches a line in error.log'],
        ['', '058-tcp-socket.t', 'TEST 8: resolver error (host not found)'],
        ['', '058-tcp-socket.t', 'TEST 9: resolver error (timeout) - response_body_like - response is expected'],
        ['', '058-tcp-socket.t', qr/wrong ident \d+ response for blah-blah-not-found\.agentzh\.org/],
        ['v', '023-rewrite/tcp-socket.t', 'TEST 9: resolver error (timeout) - response_body_like'],
        ['w', '023-rewrite/req-socket.t', 'TEST 7: Expect & 100 Continue'],
        ['w', '072-conditional-get.t', 'TEST 3: If-Unmodified-Since false'],
        ['w', '067-req-socket.t', 'TEST 7: Expect & 100 Continue'],
        ['w', '100-client-abort.t', 'TEST 27: ngx.say - pattern "say failed: nginx output filter error" matches a line in error.log'],
        ['w', '100-client-abort.t', 'TEST 28: ngx.print - pattern "print failed: nginx output filter error" matches a line in error.log'],
        ['w', '100-client-abort.t', 'TEST 31: ngx.eof - pattern "eof failed: nginx output filter error" matches a line in error.log'],
        ['w', '100-client-abort.t', 'TEST 31: ngx.eof - pattern "eof succeeded" should not match any line in error.log but matches line'],
        ['w', '020-subrequest.t', 'TEST 65: DELETE - stap output expected'],
        ['v', '062-count.t', 'matches a line in error.log'],
        ['v', '075-logby.t', 'matches a line in error.log'],
        ['v', '023-rewrite/sleep.t', qr/TEST 3: sleep 0\.5 in subrequestg? - response_body_like - response is expected/],
        ['v', '023-rewrite/sleep.t', 'TEST 1: sleep 0.5 - response_body_like - response is expected'],
        ['v', '023-rewrite/sleep.t', 'TEST 5: sleep 0.5 - multi-times - response_body_like'],
        ['v', '024-access/sleep.t', qr/TEST 3: sleep 0\.5 in subrequestg? - response_body_like - response is expected/],
        ['v', '024-access/sleep.t', 'TEST 1: sleep 0.5 - response_body_like - response is expected'],
        ['v', '033-ctx.t', 'pattern "ctx.foo = 32" matches a line in error.log'],
        ['v', '077-sleep.t', 'TEST 1: sleep 0.5 - content - response_body_like - response is expected'],
        ['v', '077-sleep.t', 'TEST 3: sleep 0.5 in subrequest - content - response_body_like - response is expected'],
        ['v', '018-ndk.t', 'matches a line in error.log'],
        ['v', '085-if.t', 'TEST 6: log_by_lua inherited by location if - pattern "from log by lua" matches a line in error.log'],
        ['v', '089-phase.t', 'TEST 8: get_phase in log_by_lua - pattern "log" matches a line in error.log'],
        ['v', '087-udp-socket.t', 'TEST 9: read timeout and resend - pattern "lua udp socket read timed out" matches a line in error.log'],
        ['v', '023-rewrite/client-abort.t', 'matches a line in error.log'],
        ['v', '023-rewrite/on-abort.t', 'matches a line in error.log'],
        ['v', '023-rewrite/on-abort.t', 'TEST 8: ignore the client abort event in the user callback (no check) - status code ok'],
        ['v', '023-rewrite/on-abort.t', 'TEST 8: ignore the client abort event in the user callback (no check) - response_body - response is expected'],
        ['v', '024-access/on-abort.t', 'TEST 8: ignore the client abort event in the user callback (no check) - status code ok'],
        ['v', '024-access/on-abort.t', 'TEST 8: ignore the client abort event in the user callback (no check) - response_body - response is expected'],
        ['v', '101-on-abort.t', 'TEST 8: ignore the client abort event in the user callback (no check) - status code ok'],
        ['v', '101-on-abort.t', 'TEST 8: ignore the client abort event in the user callback (no check) - response_body - response is expected'],
        ['v', '024-access/client-abort.t', 'matches a line in error.log'],
        ['v', '024-access/on-abort.t', 'matches a line in error.log'],
        ['v', '100-client-abort.t', 'matches a line in error.log'],
        ['v', '101-on-abort.t', 'matches a line in error.log'],
        ['v', '087-udp-socket.t', 'matches a line in error.log'],
        ['v', '106-timer.t', 'matches a line in error.log'],
        ['v', '107-timer-errors.t', 'matches a line in error.log'],
        ['v', '108-timer-safe.t', 'matches a line in error.log'],
        ['v', '109-timer-hup.t', 'matches a line in error.log'],
        ['v', '089-phase.t', 'matches a line in error.log'],
        ['v', '043-shdict.t', 'TEST 60: get_stale: expired entries can still be fetched - response_body - response is expected'],
        ['v', '067-req-socket.t', 'TEST 13: failing reread after reading timeout happens - response_body - response is expected'],
        ['v', '067-req-socket.t', 'TEST 14: successful reread after reading timeout happens (receive -> receive) - response_body - response is expected'],
        ['v', '067-req-socket.t', 'TEST 15: successful reread after reading timeout happens (receive -> receiveuntil) - response_body - response is expected'],
        ['v', '067-req-socket.t', 'TEST 16: successful reread after reading timeout happens (receiveuntil -> receive) - response_body - response is expected'],
        ['hv', '024-access/on-abort.t', 'should not match any line in error.log but matches line'],
        #['', '023-rewrite/on-abort.t', 'TEST 10: ignore the client abort event in the user callback (uthread) - stap output expected'],
        ['wv', '023-rewrite/on-abort.t', 'TEST 8: ignore the client abort event in the user callback (no check) - pattern "client prematurely closed connection" should not match any line in error.log but matches line'],
        ['wv', '024-access/on-abort.t', 'TEST 8: ignore the client abort event in the user callback (no check) - pattern "client prematurely closed connection" should not match any line in error.log but matches line'],
        ['wv', '101-on-abort.t', 'TEST 8: ignore the client abort event in the user callback (no check) - pattern "client prematurely closed connection" should not match any line in error.log but matches line'],
        ['wv', '020-subrequest.t', 'TEST 54: forwarding in-file request bodies to multiple subrequests (exceeding client_body_buffer_size)'],
        ['rv', '116-raw-req-socket.t', qr/TEST 9: receive timeout - pattern "server: .*?" matches a line in error\.log/],
        ['rv', '020-subrequest.t', 'TEST 54: forwarding in-file request bodies to multiple subrequests (exceeding client_body_buffer_size)'],
        ['rv', '058-tcp-socket.t', 'TEST 40: successful reread after a read time out happen (receiveuntil -> receive) - response_body - response is expected'],
        ['rv', '058-tcp-socket.t', 'TEST 37: successful reread after a read time out happen (receive -> receive) - response_body - response is expected'],
        ['rv', '058-tcp-socket.t', 'TEST 39: successful reread after a read time out happen (receiveuntil -> receiveuntil) - response_body - response is expected'],
        ['rv', '058-tcp-socket.t', 'TEST 38: successful reread after a read time out happen (receive -> receiveuntil) - response_body - response is expected'],
        ['v', '065-tcp-socket-timeout.t', 'TEST 17: re-connect after timed out - response_body - response is expected'],
        ['h', '117-raw-req-socket-timeout.t', qr/TEST 2: send timeout - pattern ".*?" matches a line in error\.log/],
        ['h', '065-tcp-socket-timeout.t', 'TEST 18: re-send on the same object after a send timeout happens - response_body - response is expected'],
        ['h', '065-tcp-socket-timeout.t', 'TEST 18: re-send on the same object after a send timeout happens - pattern "lua tcp socket write timed out" matches a line in error.log'],
        ['h', '108-timer-safe.t', qr/TEST 7: simple at \(sleep in the timer callback\) - log_by_lua - pattern .*? matches a line in error\.log/],
        ['h', '043-shdict.t', '- response_body'],
        ['h', '009-log.t', 'TEST 16: ngx.log() big data - pattern "(?-xism:ah{1970}b)" matches a line in error.log'],
        ['h', '023-rewrite/socket-keepalive.t', 'TEST 11: sanity (uds) - pattern "lua tcp socket keepalive: free connection pool for " should not match any line in error.log'],
        ['h', '023-rewrite/tcp-socket.t', qr{pattern "\[error\]" should not match any line in error\.log but matches line .*? wrong ident \d+ response for}],
        ['h', '068-socket-keepalive.t', qr/pattern ".*?" should not match any line in error\.log/],
        ['h', '068-socket-keepalive.t', qr/pattern ".*?" matches a line in error\.log/],
        ['h', '068-socket-keepalive.t', 'TEST 17: custom pools (same pool for the same path) - unix - response_body - response is expected'],
        ['h', '057-flush-timeout.t', 'TEST 1: flush wait - timeout'],
        ['h', '058-tcp-socket.t', 'unexpected response for blah-blah-not-found.agentzh.org'],
        ['h', '023-rewrite/tcp-socket.t', 'unexpected response for blah-blah-not-found.agentzh.org'],
        ['h', '023-rewrite/tcp-socket-timeout.t', 'TEST 15: sock:settimeout(-1) does not override lua_socket_send_timeout'],
        ['h', '023-rewrite/tcp-socket-timeout.t', 'TEST 11: lua_socket_send_timeout only'],
        ['h', '023-rewrite/tcp-socket-timeout.t', 'TEST 12: sock:settimeout() overrides lua_socket_send_timeout'],
        ['h', '023-rewrite/tcp-socket-timeout.t', 'TEST 14: sock:settimeout(0) does not override lua_socket_send_timeout'],
        ['h', '023-rewrite/tcp-socket-timeout.t', 'TEST 13: sock:settimeout(nil) does not override lua_socket_send_timeout'],
        ['h', '065-tcp-socket-timeout.t', 'TEST 11: lua_socket_send_timeout only'],
        ['h', '065-tcp-socket-timeout.t', 'TEST 12: sock:settimeout() overrides lua_socket_send_timeout'],
        ['h', '065-tcp-socket-timeout.t', 'TEST 13: sock:settimeout(nil) does not override lua_socket_send_timeout'],
        ['h', '065-tcp-socket-timeout.t', 'TEST 14: sock:settimeout(0) does not override lua_socket_send_timeout'],
        ['h', '065-tcp-socket-timeout.t', 'TEST 15: sock:settimeout(-1) does not override lua_socket_send_timeout'],
        ['h', '065-tcp-socket-timeout.t', 'TEST 16: exit in user thread (entry thread is still pending on tcpsock:send)'],
        ['h', '106-timer.t', qr/TEST 9: simple at \(sleep in the timer callback\) - log_by_lua - pattern .*? matches a line in error\.log/],
        ['hv', '024-access/on-abort.t', 'TEST 8: ignore the client abort event in the user callback (no check) - pattern "main handler done" should not match any line in error.log but matches line'],
        ['rv', '104-req-raw-header.t', 'TEST 3: large header (no request line)'],
        ['rv', '104-req-raw-header.t', 'TEST 11: large header, pipelined'],
        ['rv', '104-req-raw-header.t', 'TEST 9: large header, with lots of leading CRLF, excluding request line'],
        ['rv', '104-req-raw-header.t', 'TEST 8: large header, with leading CRLF, excluding request line'],
        ['rv', '104-req-raw-header.t', 'TEST 7: large header, with leading CRLF'],
        ['rv', '104-req-raw-header.t', 'TEST 2: large header'],
        ['rv', '104-req-raw-header.t', 'TEST 13: large header, multi-line header'],
        ['rv', '104-req-raw-header.t', 'TEST 17: large header (POST body) - in subrequests'],
        ['rv', '104-req-raw-header.t', 'TEST 16: large header (POST body)'],
    ],

    ngx_drizzle => [
        ['h', 'status.t', ' - response_body'],
    ],

    ngx_headers_more => [
        ['rv', 'input.t', 'TEST 4: try to rewrite content length using the rewrite module'],
        ['rv', 'input.t', qr/Looks like you planned \d+ tests but ran \d+\./],
        ['o', 'unused.t', 'matches a line in error.log'],
        ['hv', 'unused.t', 'TEST 3: unused output filter (with more_set_input_headers only) - pattern "headers more header filter" should not match any line in error.log but matches line'],
        ['hv', 'unused.t', 'TEST 2: unused output filter (none) - pattern "headers more header filter" should not match any line in error.log but matches line'],
        ['h', 'unused.t', 'TEST 3: unused output filter (with more_set_input_headers only) - pattern "headers more header filter" should not match any line in error.log but matches line'],
        ['h', 'unused.t', 'TEST 2: unused output filter (none) - pattern "headers more header filter" should not match any line in error.log but matches line'],
    ],

    ngx_echo => [
        ['o', undef, 'matches a line in error.log'],
        ['r', 'echo-timer.t'],
        ['rv', 'request-body.t', 'TEST 1: big client body buffered into temp files'],
        ['rv', 'request-body.t', 'ERROR: client socket timed out - TEST 3: big client body buffered into temp files (trailing echo)'],
        ['rv', 'request-body.t', 'TEST 3: big client body buffered into temp files (trailing echo) - status code ok'],
        ['rv', 'request-body.t', 'TEST 3: big client body buffered into temp files (trailing echo) - response_body - response is expected'],
        ['rv', 'request-body.t', 'Looks like you planned 4 tests but ran 6.'],
        ['rv', 'request-info.t', 'TEST 12: large header'],
        ['rv', 'request-info.t', 'TEST 14: large header, with leading CRLF'],
        ['rv', 'request-info.t', 'TEST 16: large header, pipelined'],
        ['rv', 'request-info.t', 'TEST 18: large header, multi-line header'],
        ['rv', 'request-info.t', 'TEST 21: large header (POST body)'],
        ['rv', 'request-info.t', 'TEST 22: large header (POST body) - in subrequests'],
        ['v', 'echo-timer.t', 'TEST 1: timer without explicit reset - response_body_like - response is expected'],
        ['v', 'echo-timer.t', 'TEST 2: timer without explicit reset and sleep - response_body_like - response is expected'],
        ['v', 'echo-timer.t', 'TEST 3: timing accumulated sleeps - response_body_like - response is expected'],
        ['v', 'echo-timer.t', 'TEST 4: timer with explicit reset but without sleep - response_body_like - response is expected'],
        ['v', 'echo-timer.t', 'TEST 5: reset timer between sleeps - response_body_like - response is expected'],
        ['v', 'echo-timer.t', 'TEST 6: reset timer between blocking sleeps - response_body_like - response is expected'],
        ['v', 'location-async.t', 'TEST 6: timed multiple subrequests (blocking sleep) - response_body_like - response is expected'],
        ['v', 'location-async.t', 'TEST 7: timed multiple subrequests (non-blocking sleep) - response_body_like - response is expected'],
        ['v', 'location.t', 'TEST 8: timed multiple subrequests (non-blocking sleep) - response_body_like - response is expected'],
        ['v', 'location.t', 'TEST 7: timed multiple subrequests (blocking sleep) - response_body_like - response is expected'],
        ['v', 'subrequest-async.t', 'TEST 8: timed multiple subrequests (non-blocking sleep) - response_body_like - response is expected'],
        ['v', 'subrequest-async.t', 'TEST 7: timed multiple subrequests (blocking sleep) - response_body_like - response is expected'],
        ['v', 'subrequest.t', 'TEST 6: timed multiple subrequests (blocking sleep) - response_body_like - response is expected'],
        ['v', 'subrequest.t', 'TEST 7: timed multiple subrequests (non-blocking sleep) - response_body_like - response is expected'],
        ['r', 'request-info.t', 'TEST 18: large header, multi-line header'],
    ],
);

my $failure;
my $in_failure;
my $in_valgrind_warning;
my $rec;
my $date;
my $arch;
my @records;
my $test_name;
my $leak_test_samples;
my $luajit_rev;
my $luajit_ver;
my $making_luajit;

while (<>) {
    if ($in_valgrind_warning) {
        if (/^\}$/) {
            undef $in_valgrind_warning;
            $failure->{details} .= $_;
            next;

        } elsif (/^(?:\{|\s+|==\d+== )/) {
            $failure->{details} .= $_;
            next;

        } else {
            undef $in_valgrind_warning;
        }
    }

    if ($in_failure && !/^\# /) {
        undef $in_failure;
    }

    if ($making_luajit && /Updating [a-f0-9]+\.\.([a-f0-9]+)/) {
        $luajit_rev = $1;
    }

    if (!defined $luajit_ver && m/=== Installing LuaJIT (\d+\S+)/) {
        $luajit_ver = $1;
    }

    if (!defined $date && /^(?:DATE )?(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2})$/) {
        $date = $1;
        next;
    }

    if (!defined $arch) {
        if (/^(?:ARCH )?Linux .*\bi386\b/) {
            $arch = 'linux i386';

            warn "$arch\n";

        } elsif (/^(?:ARCH )?Linux .*\bx86_64\b/) {
            $arch = 'linux x86_64';

            warn "$arch\n";
        }
    }

    if (/^making (\S+) \.\.\.$/) {
        my $subj = $1;

        if ($subj =~ /^luajit/) {
            $making_luajit = 1;

        } else {
            undef $making_luajit;
        }

        if ($subj =~ /^t([rvwhlo]*)-(sregex|(?:ngx_|lua-)[-_A-Za-z0-9]+)$/) {
            my ($mode, $module) = ($1, $2);

            print "t$mode-$module\t";

            if ($rec) {
                if (!$rec->{commit}) {
                    my $line = $rec->{line};
                    die "line $line: No git commit found.\n";
                }

                my $n = @{ $rec->{failures} };
                if ($n >= 2) {
                    my $a = $rec->{failures}[$n - 1];
                    my $b = $rec->{failures}[$n - 2];
                    if (((!defined $a->{file} && !defined $b->{file}) || $a->{file} eq $b->{file})
                        && ((!defined $a->{name} && !defined $b->{name}) || $a->{name} eq $b->{name})
                        && ((!defined $a->{details} && !defined $b->{details})
                            || $a->{details} eq $b->{details}))
                    {
                        #warn "remove duplicate test failures";
                        pop @{ $rec->{failures} };
                    }
                }

                #@{ $rec->{failures} } = uniq @{ $rec->{failures} };
            }

            $rec = {
                module => $module,
                mode => $mode,
                line => $.,
                tests_pass => 0,
                valgrind_pass => 1,
                failures => [],
                valgrind_warnings => [],
                warns => [],
                comp_errors => [],
                luajit_ver => $luajit_ver,
                luajit_rev => $luajit_rev,
            };

            push @records, $rec;

        } else {
            #warn "ignoring $subj\n";
            undef $rec;
        }

    } elsif ($rec && !defined $rec->{commit} && /^commit ([0-9a-f]+)$/) {
        $rec->{commit} = $1;

    } elsif ($rec && defined $rec->{commit} && !defined $rec->{commit_date}
             && /Date:\s+([A-Z][a-z]{2} [A-Z][a-z]{2} \d+ .*)/)
    {
        $rec->{commit_date} = str2time($1);

    } elsif ($rec && !defined $rec->{nginx_version} && m{^nginx version: (.*)}) {
        (my $ver = $1) =~ s/without pool/no pool/;
        $rec->{nginx_version} = $ver;

    } elsif ($rec && m{^(nginx: \[(?:emerg|alert|error)\]) (.*)}) {

        my ($name, $details) = ($1, $2);

        if ($name eq 'nginx: [alert]' && $details =~ /lua_code_cache is off/) {
            next;
        }

        $failure = {
            name => $name,
            details => $details,
        };

        push @{ $rec->{failures} }, $failure;

    } elsif ($rec && m{^\./configure: error: (.+)}) {
        $rec->{config_error} = $1;

    } elsif ($rec && m{^/home/\S+?\w+\.c:\d+:\d+: error: .*}) {
        push @{ $rec->{comp_errors} }, $&;

    } elsif ($rec && m{^sh: -c: line \d+: .*error}) {
        push @{ $rec->{comp_errors} }, $&;

    } elsif ($rec && /\bWARNING: (.+)/) {
        my $warning = $1;
        #warn "Found warning: $1\n";
        if (@{ $rec->{warns} } && $rec->{warns}[-1] eq $warning) {
            next;
        }

        push @{ $rec->{warns} }, $warning;

    } elsif ($rec && m{\./util/build2?\.sh (\d+\.\d+\.\d+)\b}) {
        $rec->{nginx_version} = "nginx/$1 (no pool)";

    } elsif ($rec && $rec->{mode} !~ /l/ && /^All tests successful/) {
        $rec->{tests_pass} = 1;

    } elsif ($rec && $rec->{mode} =~ /l/ && /LeakTest: \[(.*?)\]/) {
        $leak_test_samples = $1;

    } elsif ($rec && $rec->{mode} =~ /l/ && /LeakTest: k=(\d+(?:\.\d+)?)/) {
        my $k = $1;
        if ($k >= 10) {
            $leak_test_samples ||= '';

            my @samples = split /\s+/, $leak_test_samples;
            my $up_edges = get_up_edges(\@samples);
            my $stable = get_stable_point(\@samples);

            $failure = {
                name => $test_name,
                details => "${_}Up-Edges: $up_edges\n"
                            . "Stable point: ". ($stable || "N/A") . "\n\n"
                            . "RSS Samples (in KB):\n$leak_test_samples",
                chart => gen_chart_uri($leak_test_samples),
                stable => $stable,
                up_edges => $up_edges,
            };

            push @{ $rec->{failures} }, $failure;
        }

    } elsif ($rec && /^(Bailout called\.\s*)(.*)/) {
        $failure = {
            name => $1,
            details => $2,
        };

        push @{ $rec->{failures} }, $failure;

    } elsif ($rec && /\# Looks like you planned \d+ tests? but ran \d+\./) {

        $failure = {
            name => $&,
            details => '',
        };

        push @{ $rec->{failures} }, $failure;

    } elsif ($rec && /^Files=(\d+),\s+Tests=(\d+),\s+(\d+)\s+wallclock secs/) {

        $rec->{files} = $1;
        $rec->{tests} = $2;
        $rec->{secs} = $3;

    } elsif (/^TEST \d+: .*/) {
        $test_name = $&;

    } elsif ($rec && $rec->{mode} =~ /v/ && /^==\d+==\s+/) {
        $failure = {
            name => $test_name,
            details => $_,
        };

        push @{ $rec->{failures} }, $failure;

        #warn "Found valgrind warning: $&\n";

        $in_valgrind_warning = 1;

        $rec->{valgrind_pass} = 0;

    } elsif ($rec && ($rec->{mode} !~ /l/ || /the nginx process \d+ is gone/) && /^\#\s+Failed test '(.*?)'?$/) {
        my $name = $1;
        #warn "$rec->{module}: $rec->{mode}: $name\n";
        $failure = {
            name => $name,
        };

        push @{ $rec->{failures} }, $failure;

        $in_failure = 1;

    } elsif ($rec && $rec->{mode} !~ /l/ && $in_failure && /^\# (.*)/) {
        my $s = $1;
        if ($s =~ /^\s*at .*?\w+\.pm line \d+\.$/
            || $s =~ /^\s*Looks like you failed \d+ tests of \d+\.\s*$/)
        {
            next;
        }

        $failure->{details} .= "$s\n";

    } elsif ($rec && m{^t/(\S+\.t) \.+ }) {

        my $file = $1;
        #warn "file $file\n";
        my $failures = $rec->{failures};
        my $i = @$failures - 1;
        while ($i >= 0) {
            my $f = $failures->[$i];
            if (defined $f->{file}) {
                last;
            }

            $f->{file} = $file;

            $i--;
        }
    }
}

for my $rec (@records) {
    my $mode = $rec->{mode};
    my $module = $rec->{module};

    if ($verbose) {
        print $mode, ": ", $module, ": ";
    }

    if ($rec->{comp_errors}) {
        @{ $rec->{comp_errors} } = uniq @{ $rec->{comp_errors} };
    }

    if (($rec->{tests_pass} && $rec->{valgrind_pass})
        || ($rec->{mode} =~ /l/ && !@{ $rec->{failures} }))
    {
        if ($verbose) {
            print "\e[32mPASS\e[39m\n";
        }

        $rec->{result} = 'PASS';

        $rec->{true_fails} = [];
        $rec->{expected_fails} = [];

    } else {

        my (@fails, @expected_fails);

        my $specs = $white_list{$module};
        if ($specs) {
            for my $f (@{ $rec->{failures} }) {
                my $expected;
                for my $spec (@$specs) {
                    if (!defined $spec->[0] || $mode =~ /$spec->[0]/) {
                        #warn "mode $mode matched $spec->[0]";
                        my $file = $spec->[1];

                        if (defined $file) {
                            if (defined $f->{file} && $f->{file} eq $file) {
                                #warn "Hit $file!";
                                my $test = $spec->[2];
                                if (defined $test) {
                                    if ($f->{name} =~ /(?:$test)|\Q$test\E/) {
                                        #warn "Matched \"$f->{name}\" with \"$test\"";
                                        $expected = 1;
                                        last;

                                    }

                                } else {
                                    #warn "Matched mode $spec->[0] and file $spec->[1]";
                                    $expected = 1;
                                    last;
                                }
                            }

                        } else {
                            #warn "Matched mode $spec->[0]";
                            my $test = $spec->[2];
                            if (defined $test) {
                                if ($f->{name} =~ /(?:$test)|\Q$test\E/) {
                                    #warn "Matched \"$f->{name}\" with \"$test\"";
                                    $expected = 1;
                                    last;

                                }

                            } else {
                                #warn "Matched mode $spec->[0] and file $spec->[1]";
                                $expected = 1;
                                last;
                            }
                        }
                    }
                }

                if ($expected) {
                    if (@expected_fails) {
                        my $last = $expected_fails[-1];
                        if ($last->{file} eq $f->{file}
                            && $last->{name} eq $f->{name}
                            && ((!defined $last->{details} && !defined $f->{details})
                                || $last->{details} eq $f->{details}))
                        {
                            pop @expected_fails;
                        }
                    }

                    push @expected_fails, $f;

                } else {
                    push @fails, $f;
                }
            }

        } else {
            @fails = @{ $rec->{failures} };
        }

        if ($rec->{mode} =~ /l/) {
            my @fails2;
            for my $fail (@fails) {
                if ($fail->{stable}
                    || (defined $fail->{up_edges} && $fail->{up_edges} < 10))
                {
                    push @expected_fails, $fail;

                } else {
                    push @fails2, $fail;
                }
            }
            @fails = @fails2;
        }

        $rec->{true_fails} = \@fails;
        $rec->{expected_fails} = \@expected_fails;
        delete $rec->{failures};

        if (!@fails && $rec->{tests}) {
            if ($verbose) {
                print "\e[33mPASS\e[39m\n";
            }

            $rec->{result} = '~PASS';

        } else {
            if ($verbose) {
                print "\e[31mFAIL\e[39m\n";
            }

            $rec->{result} = 'FAIL';

            if (@fails && ($module ne 'ngx_postgres' || $mode !~ /w/)) {
                if ($verbose) {
                    print join("\n", map { "@$_" } @fails), "\n";
                }
            }
        }
    }

    if (@{ $rec->{valgrind_warnings} }) {
        #print @{ $rec->{valgrind_warnings} };
    }
}

my $json_xs = JSON::XS->new->ascii->pretty;

my $res = {
    arch => $arch,
    date => $date,
    records => \@records,
};

open my $out, ">$outfile" or
    die "Cannot open $outfile for writing: $!\n";

print $out $json_xs->encode($res);

close $out;

sub usage {
    die "Usage: $0 [-v] -o <outfile> <infile>\n";
}

sub gen_chart_uri {
    my $samples = shift;
    if (!$samples) {
        return undef;
    }

    my @ys = split /\s+/, $samples;
    my $max = max @ys;
    @ys = map { sprintf "%.0f", ($_ * 100 / $max) } @ys;
    my $ys = join ",", @ys;
    return "https://chart.googleapis.com/chart?cht=lc&chd=t:$ys&chs=200x80&chco=3072F3"
}

sub get_stable_point {
    my $samples = shift;
    my $n = @$samples;
    if (!$n) {
        return undef;
    }

    my $m = int (($n - 1) * 0.65);
    if ($m < 0) {
        $m = 0;
    }

    my $p;
    for (my $i = $m; $i < $n; $i++) {
        if (!defined $p) {
            $p = $samples->[$i];
        } else {
            if ($p == $samples->[$i]) {
                next;
            }

            return undef;
        }
    }

    return $p;
}

sub get_up_edges {
    my $samples = shift;
    if (!@$samples) {
        return 0;
    }

    my @ys = @$samples;
    my $a = shift @ys;
    my $edges = 0;
    while (@ys) {
        my $b = shift @ys;
        my $diff = $b - $a;
        if ($diff > 0) {
            $edges++;

        } elsif ($diff < 0) {
            $edges--;
        }

        $a = $b;
    }

    return $edges;
}

print "\n";


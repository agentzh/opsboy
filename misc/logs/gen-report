#!/usr/bin/env perl

use strict;
use warnings;

use JSON::XS;
use Template;

my $dir = shift
    or die "No input directory specified.\n";

my @jsonfiles = glob "$dir/*.json";
if (!@jsonfiles) {
    die "No JSON files found under $dir/.\n";
}

my $data = {
};

my $jsonxs = JSON::XS->new->ascii;

for my $jsonfile (@jsonfiles) {
    open my $in, $jsonfile
        or die "Cannot open $jsonfile for reading: $!\n";
    my $json = do { local $/; <$in> };
    close $in;

    my $ast = $jsonxs->decode($json);

    my $arch = $ast->{arch};
    my $arch_group;
    if (!defined $data->{$arch}) {
        $arch_group = {};
        $data->{$arch} = $arch_group;

    } else {
        $arch_group = $data->{$arch};
    }

    my $test_date = $ast->{date};

    my $recs = $ast->{records};
    for my $rec (@$recs) {
        my $nginx_version = $rec->{nginx_version};
        my $nginx_group;
        if (!defined $arch_group->{$nginx_version}) {
            $nginx_group = {};
            $arch_group->{$nginx_version} = $nginx_group;
        } else {
            $nginx_group = $arch_group->{$nginx_version};
        }

        my $module = $rec->{module};
        my $module_group;
        if (!defined $nginx_group->{$module}) {
            $module_group = {};
            $nginx_group->{$module} = $module_group;
        } else {
            $module_group = $nginx_group->{$module};
        }

        my $mode = $rec->{mode};
        my $mode_group;
        if (!defined $module_group->{$mode}) {
            $mode_group = {};
            $module_group->{$mode} = $mode_group;
        } else {
            $mode_group = $module_group->{$mode};
        }

        if (defined $mode_group->{test_date}
            && defined $mode_group->{commit_date})
        {
            if ($test_date lt $mode_group->{test_date}) {
                warn "Skip $arch > $nginx_version > $module > $mode ($test_date).\n";
                next;
            }

            #warn "Overriding $arch > $nginx_version > $module > $mode ($test_date later than $mode_group->{test_date})\n";
        }

        $mode_group->{test_date} = $test_date;
        $mode_group->{commit_date} = $rec->{commit_date};
        $mode_group->{result} = $rec->{result};
        $mode_group->{failures} = $rec->{failures};
        $mode_group->{true_fails} = $rec->{true_fails};
        $mode_group->{tests} = $rec->{tests};
    }
}

#print $jsonxs->pretty->encode($data);

mkdir 'html/' if ! -d 'html/';

my $tt2 = Template->new;

for my $arch_name (sort keys %$data) {
    my $arch = $data->{$arch_name};
    (my $arch_anchor = $arch_name) =~ s/[^-\w]/_/g;
    for my $ngx_ver (sort keys %$arch) {
        my $ngx = $arch->{$ngx_ver};
        (my $ngx_anchor = $ngx_ver) =~ s/[^-\w]/_/g;
        $ngx_anchor = $arch_anchor . '_' . $ngx_anchor;

        for my $module_name (sort keys %$ngx) {
            my $module = $ngx->{$module_name};

            for my $mode_name (sort keys %$module) {
                my $mode = $module->{$mode_name};

                my $link = $ngx_anchor . '_' . $module_name . '_'
                    . $mode_name . '.html';

                $mode->{link} = $link;

                my $outfile = "html/$link";

                $tt2->process('details.tt', {
                    name => $module_name,
                    arch => $arch_name,
                    mode => $mode_name,
                    rec => $mode,
                }, $outfile) or die $tt2->error();

                warn "wrote $outfile\n";
            }
        }

        $ngx->{anchor} = $ngx_anchor;
    }
    #warn $arch_name;
    $arch->{anchor} = $arch_anchor;
}

my $outfile = "html/index.html";

$tt2->process('index.tt', { ast => $data }, 'html/index.html')
    or die $tt2->error();

warn "wrote $outfile\n";

